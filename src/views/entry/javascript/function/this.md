## this

在详细阐述`this`问题之前，我们先来了解一下Javascript中的作用域

# 作用域
在ES6之前，变量的声明提前会在程序正式执行之前，针对的，就是变量声明以及函数声明(现将所有var 声明的变量以及function声明的函数提到当前作用域的顶部，集中创建)。作用域用来控制一个变量的可用范围，其实就是一个保存变量的对象。避免不同范围的变量间互相干扰。js中包括两级作用域:

1. 全局作用域：保存全局变量，可重复使用，随处可用
2. 函数作用域：保存局部变量，仅函数内部可用，包括在函数内var的，还有参数内定义的

作用域链：有多级作用域对象，逐级引用形成的链式结构，作用域与作用域链关系到`JS`程序的运行机制：

1. 程序开始执行前：在内存中创建执行环境栈(数组)，依次保存正在调用的函数的数组，函数调用后会出栈；接着在栈中首先添加浏览器主函数的调用；主函数会创建全局作用域对象`window`。
2. 定义函数时：在`window`中用函数名创建变量，在`window`外创建函数对象保存函数的内容；函数名变量通过地址引用函数对象，函数对象用隐藏的`scope`属性，引用回自己诞生的作用域对象。(对于函数来说，在创建的时候会用一个`scope`对象保存这个函数被创建的地方，形象的说就是记住这个函数的爹，目的就是为了，如果这个函数内部的代码执行起来之后缺东西，自己这边没有，他可以通过`scope`这个对象找到他上一个作用域，然后问上一个作用域要这个缺的东西)。
3. 函数执行时：在执行环境栈中添加当前函数调用，为本次函数调用创建活动对象`AO`(函数的作用域对象)，在活动对象中创建函数的局部变量并保存，活动对象通过隐藏的parent属性引用上一级作用域对象。
4. 函数执行完毕后：函数从执行环境栈出栈，接着函数作用域对象释放，所以局部变量也会随着作用域对象的释放一同释放。

# 上下文环境
`this`原本是指向当前函数的执行栈环境，这个执行栈环境，可以是一个函数，也可以是一个对象，如果用一句话来总结怎么判断`this`指向——谁调用的这个函数，`this`就指向谁。这句话可能有些笼统，我们可以分开论述，在`ES6`之前，函数内部的`this`是由该函数的调用方式决定的:

1. 函数调用方式，`this`指向`window`

2. 方法调用方式，`this`指向调用该方法的对象

3. `new`关键字调用构造函数，函数内部的`this`会指向构造函数的实例

我们所说的`this`，无非就是要调用变量，不同的变量是由不同的运行环境提供的，而不同的运行环境又由不同的运行函数提供，所以，`this`的出现，其实是为了获得当前的运行环境。this没有作用域的限制，this并不受函数作用域的限制，一个函数A的内部定义一个函数B，在B的内部并不能继承A函数的this，如果嵌套函数作为方法调用，其this的值指向调用它的对象，嵌套函数作为函数调用，其this值不是全局对象就是undefined。如果想要访问这个外部函数的this值，需要将this的值保存在一个变量里。